<!DOCTYPE html>
<html>
	<head>
		<script src="gl-matrix-min.js"></script>
		<script src="tree.js"></script>
		<script>
			var gl;
			var buffers;  // vertex, norm, uv, index, model0, model1, model2, model3
			var attributes;  // [pos, uv, model0, model1, model2, model3], [proj, view, tex]
			var textures;  // [tree]
			var vm, pm;

			Array.prototype.foreach = function(fn, start, limit) {
				if (start === undefined) start = 0;
				if (limit === undefined) limit = this.length;

				for (var i=start; i<limit; i++) {
					fn(this[i]);
				}
			}

			function Vertex(vert, norm, uv, model) {
				this.vertex = vert;
				this.normal = norm;
				this.uv = uv;
				this.model = model;
			}

			function getShader(gl, id) {
				var shaderScript = document.getElementById(id);
				var shader = null;

				if (!shaderScript) return null;

				if (shaderScript.type == 'x-shader/x-fragment') {
					shader = gl.createShader(gl.FRAGMENT_SHADER);
				} else if (shaderScript.type == 'x-shader/x-vertex') {
					shader = gl.createShader(gl.VERTEX_SHADER);
				} else {
					return null;
				}

				var currentChild = shaderScript.firstChild;
				var source = "";

				while (currentChild) {
					if (currentChild.nodeType == currentChild.TEXT_NODE) {
						source += currentChild.textContent;
					}
					currentChild = currentChild.nextSibling;
				}

				gl.shaderSource(shader, source);
				gl.compileShader(shader);

				if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
					alert('Error compiling shaders: ' + gl.getShaderInfoLog(shader));
					return null;
				}

				return shader;
			}

			// Returns a list of lists; first list is the attribute locations,
			// second list is the uniform locations
			function initShaders(gl) {
				var frag = getShader(gl, "frag-shader");
				var vert = getShader(gl, "vert-shader");

				var prog = gl.createProgram();
				gl.attachShader(prog, vert);
				gl.attachShader(prog, frag);
				gl.linkProgram(prog);

				if (!gl.getProgramParameter(prog, gl.LINK_STATUS)) {
					alert('Link failed: ' + gl.getProgramInfoLog(prog));
				}

				gl.useProgram(prog);

				var posAttr = gl.getAttribLocation(prog, 'pos');
				gl.enableVertexAttribArray(posAttr);

				var uvAttr = gl.getAttribLocation(prog, 'uv');
				gl.enableVertexAttribArray(uvAttr);

				var modelAttr0 = gl.getAttribLocation(prog, 'model0');
				gl.enableVertexAttribArray(modelAttr0);
				var modelAttr1 = gl.getAttribLocation(prog, 'model1');
				gl.enableVertexAttribArray(modelAttr1);
				var modelAttr2 = gl.getAttribLocation(prog, 'model2');
				gl.enableVertexAttribArray(modelAttr2);
				var modelAttr3 = gl.getAttribLocation(prog, 'model3');
				gl.enableVertexAttribArray(modelAttr3);

				var proj = gl.getUniformLocation(prog, 'proj');
				var view = gl.getUniformLocation(prog, 'view');
				var tex = gl.getUniformLocation(prog, 'texture');

				return [[posAttr, uvAttr, modelAttr0, modelAttr1, modelAttr2, modelAttr3],
				        [proj, view, tex]];
			}

			// Returns the list of buffers
			function initBuffers(gl) {
				var vertices = [], indices = [];
				var tree = new Tree(TreeType.EVERGREEN, FoliageType.UMBRELLA, false, BranchType.NORMAL);
				tree.Build(vertices, indices);
				const ROWS = 4;
				const COLS = 4;
				const VERTICES = vertices.length;

				// rearrange data in vertices
				var vertex_f32 = new Float32Array(VERTICES * 3),
					norm_f32 = new Float32Array(VERTICES * 3),
					uv_f32 = new Float32Array(VERTICES * 2),
					models_f32 = [new Float32Array(VERTICES * ROWS),
					              new Float32Array(VERTICES * ROWS),
					              new Float32Array(VERTICES * ROWS),
					              new Float32Array(VERTICES * ROWS)];
				for (var i=0; i<vertices.length; i++) {
					vertex_f32.set(vertices[i].vertex.subarray(0, 3), i*3);
					norm_f32.set(vertices[i].normal, i*3);
					uv_f32.set(vertices[i].uv, i*2);
					// copy the nth column of vertices[i].model for each vertex,
					// into each of n new Float32Arrays.  .model is really a
					// Float32Array, in column-major order; exploit that.
					for (var col = 0; col < COLS; col++) {
						var col_f32 = vertices[i].model.subarray(col*ROWS, (col+1)*ROWS);
						models_f32[col].set(col_f32, i * ROWS);
					}
				}

				var vertbuf = gl.createBuffer();
				gl.bindBuffer(gl.ARRAY_BUFFER, vertbuf);
				gl.bufferData(gl.ARRAY_BUFFER, vertex_f32, gl.STATIC_DRAW);

				var normbuf = gl.createBuffer();
				gl.bindBuffer(gl.ARRAY_BUFFER, normbuf);
				gl.bufferData(gl.ARRAY_BUFFER, norm_f32, gl.STATIC_DRAW);

				var uvbuf = gl.createBuffer();
				gl.bindBuffer(gl.ARRAY_BUFFER, uvbuf);
				gl.bufferData(gl.ARRAY_BUFFER, uv_f32, gl.STATIC_DRAW);

				var indexbuf = gl.createBuffer();
				gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexbuf);
				gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(indices), gl.STATIC_DRAW);
				// yes, this is extra
				indexbuf.length = indices.length;

				var modelbuf0 = gl.createBuffer();
				gl.bindBuffer(gl.ARRAY_BUFFER, modelbuf0);
				gl.bufferData(gl.ARRAY_BUFFER, models_f32[0], gl.STATIC_DRAW);

				var modelbuf1 = gl.createBuffer();
				gl.bindBuffer(gl.ARRAY_BUFFER, modelbuf1);
				gl.bufferData(gl.ARRAY_BUFFER, models_f32[1], gl.STATIC_DRAW);

				var modelbuf2 = gl.createBuffer();
				gl.bindBuffer(gl.ARRAY_BUFFER, modelbuf2);
				gl.bufferData(gl.ARRAY_BUFFER, models_f32[2], gl.STATIC_DRAW);

				var modelbuf3 = gl.createBuffer();
				gl.bindBuffer(gl.ARRAY_BUFFER, modelbuf3);
				gl.bufferData(gl.ARRAY_BUFFER, models_f32[3], gl.STATIC_DRAW);

				return [vertbuf, normbuf, uvbuf, indexbuf, modelbuf0, modelbuf1, modelbuf2,
				        modelbuf3];
			}

			function texLoaded(gl, img, tex) {
				gl.bindTexture(gl.TEXTURE_2D, tex);
				gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, img);
				gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
				gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR_MIPMAP_NEAREST);
				gl.generateMipmap(gl.TEXTURE_2D);
				gl.bindTexture(gl.TEXTURE_2D, null);
			}

			function initTextures(gl) {
				tree = gl.createTexture();
				treeImage = new Image();
				treeImage.onload = function() { texLoaded(gl, treeImage, tree); }
				treeImage.src = 'textures/bark1.bmp';

				return [tree];
			}

			function start() {
				var canvas = document.getElementById("glcanvas");
				gl = null;
				try {
					gl = canvas.getContext("webgl") || canvas.getContext("experimental-webgl");
				}
				catch(e) {alert(e);}

				if (!gl) {
					alert("Can't get \"webgl\" context from canvas; maybe no WebGL support?");
					return;
				}

				gl.clearColor(0.0, 0.0, 0.0, 1.0);
				gl.enable(gl.DEPTH_TEST);
				gl.depthFunc(gl.LEQUAL);
				gl.clear(gl.COLOR_BUFFER_BIT|gl.DEPTH_BUFFER_BIT);

				attributes = initShaders(gl);
				buffers = initBuffers(gl);
				textures = initTextures(gl);

				// identity * translation
				vm = mat4.create();
				mat4.translate(vm, vm, vec3.fromValues(0, -10, -50));
				pm = mat4.perspective(mat4.create(), Math.PI/4, 800.0/600.0, 0.1, 100);

				// Do I really need this extra scope?  Eh, why not.
				(function() {
					var requestAnimationFrame = (window.requestAnimationFrame ||
					                             window.mozRequestAnimationFrame ||
					                             window.webkitRequestAnimationFrame ||
					                             window.msRequestAnimationFrame);
					window.requestAnimationFrame = requestAnimationFrame;
				})();
				window.requestAnimationFrame(drawScene);
			}

			var firsttimestamp = null;
			var fpstimestamp = null;
			var frames = 0;

			function drawScene(timestamp) {
				const SECONDS = 3;  // for a full revolution
				const RADS_PER_SEC = 2*Math.PI / SECONDS;
				if (firsttimestamp === null) {
					firsttimestamp = timestamp;
				}
				if ((timestamp - firsttimestamp) > SECONDS*1000) {
					firsttimestamp += SECONDS*1000;
				}
				if (fpstimestamp !== null) {
					if (timestamp - fpstimestamp > 1000) {
						document.getElementById('fps').firstChild.textContent = frames.toFixed(0);
						fpstimestamp = timestamp;
						frames = 0;
					}
				} else {
					fpstimestamp = timestamp;
				}
				gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

				// wouldn't it be nice if javascript did python-style unpacking...
				// oh look, it does, but not in IE.  well, too bad, IE.
				var [[posattr, uvattr, modelattr0, modelattr1, modelattr2, modelattr3],
				     [proj, view, tex]] = attributes,
					[vertbuf, normbuf, uvbuf, indexbuf, modelbuf0, modelbuf1, modelbuf2,
					 modelbuf3] = buffers,
					[tree] = textures;

				// rotate around the scene once every few seconds
				radians = ((timestamp - firsttimestamp) / 1000) * RADS_PER_SEC;
				viewmatrix = mat4.create();
				mat4.rotateY(viewmatrix, vm, radians);
				gl.uniformMatrix4fv(view, false, viewmatrix);
				gl.uniformMatrix4fv(proj, false, pm);

				gl.activeTexture(gl.TEXTURE0);
				gl.bindTexture(gl.TEXTURE_2D, tree);
				gl.uniform1i(tex, 0);

				gl.bindBuffer(gl.ARRAY_BUFFER, vertbuf);
				gl.vertexAttribPointer(posattr, 3, gl.FLOAT, false, 0, 0);

				gl.bindBuffer(gl.ARRAY_BUFFER, uvbuf);
				gl.vertexAttribPointer(uvattr, 2, gl.FLOAT, false, 0, 0);

				gl.bindBuffer(gl.ARRAY_BUFFER, modelbuf0);
				gl.vertexAttribPointer(modelattr0, 4, gl.FLOAT, false, 0, 0)
				gl.bindBuffer(gl.ARRAY_BUFFER, modelbuf1);
				gl.vertexAttribPointer(modelattr1, 4, gl.FLOAT, false, 0, 0)
				gl.bindBuffer(gl.ARRAY_BUFFER, modelbuf2);
				gl.vertexAttribPointer(modelattr2, 4, gl.FLOAT, false, 0, 0)
				gl.bindBuffer(gl.ARRAY_BUFFER, modelbuf3);
				gl.vertexAttribPointer(modelattr3, 4, gl.FLOAT, false, 0, 0)

				gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexbuf);
				gl.drawElements(gl.TRIANGLES, indexbuf.length, gl.UNSIGNED_SHORT, 0);

				window.requestAnimationFrame(drawScene);

				frames++;
			}
		</script>
	</head>
	<body onload="start()">
		<canvas id="glcanvas" width="800" height="600">
		Your browser doesn't appear to support the HTML5 <code>&lt;canvas&gt;</code> element.
		</canvas>
		<p><span id="fps">???</span> FPS</p>
		<script type="x-shader/x-fragment" id="frag-shader">
			#version 100

			varying lowp vec2 vUV;

			uniform sampler2D texture;

			void main(void) {
				gl_FragColor = texture2D(texture, vUV);
			}
		</script>
		<script type="x-shader/x-vertex" id="vert-shader">
			#version 100

			attribute vec3 pos;
			attribute vec2 uv;
			attribute vec4 model0;
			attribute vec4 model1;
			attribute vec4 model2;
			attribute vec4 model3;

			uniform mat4 view;
			uniform mat4 proj;

			varying lowp vec2 vUV;

			void main(void) {
				mat4 model;
				model[0] = model0;
				model[1] = model1;
				model[2] = model2;
				model[3] = model3;
				gl_Position = proj * view * model * vec4(pos, 1.0);
				vUV = uv;
			}
		</script>
	</body>
</html>
