<!DOCTYPE html>
<html>
	<head>
		<script src="gl-matrix-min.js"></script>
		<script>
			var gl;
			var buffers;  // vertex, norm, uv, index, model0, model1, model2, model3
			var attributes;  // [pos, uv, model0, model1, model2, model3], [proj, view, tex]
			var textures;  // [tree]
			var vm, pm;

			Array.prototype.foreach = function(fn, start, limit) {
				if (start === undefined) start = 0;
				if (limit === undefined) limit = this.length;

				for (var i=start; i<limit; i++) {
					fn(this[i]);
				}
			}

			function getShader(gl, id) {
				var shaderScript = document.getElementById(id);
				var shader = null;

				if (!shaderScript) return null;

				if (shaderScript.type == 'x-shader/x-fragment') {
					shader = gl.createShader(gl.FRAGMENT_SHADER);
				} else if (shaderScript.type == 'x-shader/x-vertex') {
					shader = gl.createShader(gl.VERTEX_SHADER);
				} else {
					return null;
				}

				var currentChild = shaderScript.firstChild;
				var source = "";

				while (currentChild) {
					if (currentChild.nodeType == currentChild.TEXT_NODE) {
						source += currentChild.textContent;
					}
					currentChild = currentChild.nextSibling;
				}

				gl.shaderSource(shader, source);
				gl.compileShader(shader);

				if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
					alert('Error compiling shaders: ' + gl.getShaderInfoLog(shader));
					return null;
				}

				return shader;
			}

			// Returns a list of lists; first list is the attribute locations,
			// second list is the uniform locations
			function initShaders(gl) {
				var frag = getShader(gl, "frag-shader");
				var vert = getShader(gl, "vert-shader");

				var prog = gl.createProgram();
				gl.attachShader(prog, vert);
				gl.attachShader(prog, frag);
				gl.linkProgram(prog);

				if (!gl.getProgramParameter(prog, gl.LINK_STATUS)) {
					alert('Link failed: ' + gl.getProgramInfoLog(prog));
				}

				gl.useProgram(prog);

				var posAttr = gl.getAttribLocation(prog, 'pos');
				gl.enableVertexAttribArray(posAttr);

				var uvAttr = gl.getAttribLocation(prog, 'uv');
				gl.enableVertexAttribArray(uvAttr);

				var modelAttr0 = gl.getAttribLocation(prog, 'model0');
				gl.enableVertexAttribArray(modelAttr0);
				var modelAttr1 = gl.getAttribLocation(prog, 'model1');
				gl.enableVertexAttribArray(modelAttr1);
				var modelAttr2 = gl.getAttribLocation(prog, 'model2');
				gl.enableVertexAttribArray(modelAttr2);
				var modelAttr3 = gl.getAttribLocation(prog, 'model3');
				gl.enableVertexAttribArray(modelAttr3);

				var proj = gl.getUniformLocation(prog, 'proj');
				var view = gl.getUniformLocation(prog, 'view');
				var tex = gl.getUniformLocation(prog, 'texture');

				return [[posAttr, uvAttr, modelAttr0, modelAttr1, modelAttr2, modelAttr3],
				        [proj, view, tex]];
			}

			// Returns a vec4: x, y, z, radius
			function treeTrunkPos(height, _current_base_radius, _current_height) {
				// funnel type would do delta_curve=1-(1.0-height)*(1.0-height)
				var delta_curve = height;
				// canopy would do delta_curve*0.5
				var radius = _current_base_radius * (1.0-delta_curve);
				if (radius < 0.3) radius = 0.3;
				// BENT and JAGGED would use height*height

				return vec4.fromValues(0.0, 0.0, height*_current_height, radius);
			}

			var FoliageTypes = Object.freeze({
				PANEL: 0,
				SHIELD: 1,
				SAG: 2,
				BOWL: 3,
				UMBRELLA: 4
			});

			function makeFoliage(type, vertices, pushTri, pushQuad, pos_list, fsize, angle) {
				var uvTL = vec2.fromValues(0.25, 0.0),
				    uvTR = vec2.fromValues(0.5, 0.0),
				    uvBR = vec2.fromValues(0.5, 1.0),
				    uvBL = vec2.fromValues(0.25, 1.0),
				    base_index = vertices.length,
				    vert, norm, uv = vec2.create(),
				    tip_height = fsize / 4.0;

				// don't let foliage touch the ground
				if (fsize < (pos_list[0][2] - 2.0)) {
					fsize = (pos_list[0][2] - 2.0);
				}
				if (fsize < 0.1) {
					return;
				}

				switch(type) {
					case FoliageTypes.PANEL:
						norm = vec3.fromValues(0.0, 0.0, 1.0);

						vert = vec4.fromValues(0.0,  -fsize, -fsize, 0.0);
						vertices.push([vert, norm, uvTL]);

						vert = vec4.fromValues(-1.0,  fsize, -fsize, 0.0);
						vertices.push([vert, norm, uvTR]);

						vert = vec4.fromValues(-1.0,  fsize,  fsize, 0.0);
						vertices.push([vert, norm, uvBR]);

						vert = vec4.fromValues(0.0,  -fsize,  fsize, 0.0);
						vertices.push([vert, norm, uvBL]);

						vert = vec4.fromValues(0.0,  -fsize, -fsize, 0.0);
						vertices.push([vert, norm, uvTR]);

						vert = vec4.fromValues(1.0,   fsize, -fsize, 0.0);
						vertices.push([vert, norm, uvBR]);

						vert = vec4.fromValues(1.0,   fsize,  fsize, 0.0);
						vertices.push([vert, norm, uvBL]);

						vert = vec4.fromValues(0.0,  -fsize,  fsize, 0.0);
						vertices.push([vert, norm, uvTL]);

						pushQuad(base_index + 0, base_index + 1, base_index + 2, base_index + 3);
						pushQuad(base_index + 7, base_index + 6, base_index + 5, base_index + 4);

						break;
					case FoliageTypes.SHIELD:
						norm = vec3.fromValues(0.0, 0.0, 1.0);

						vert = vec4.fromValues(fsize / 2, 0.0,  0.0, 0.0);
						vec2.lerp(uv, uvTL, uvBR, 0.5);
						vertices.push([vert, norm, uv]);

						vert = vec4.fromValues(0.0, -fsize, 0.0, 0.0);
						vertices.push([vert, norm, uvTL]);

						vert = vec4.fromValues(0.0,  0.0,  fsize, 0.0);
						vertices.push([vert, norm, uvTR]);

						vert = vec4.fromValues(0.0,  fsize, 0.0, 0.0);
						vertices.push([vert, norm, uvBR]);

						vert = vec4.fromValues(0.0,  0.0,  -fsize, 0.0);
						vertices.push([vert, norm, uvBL]);

						// uv is still the lerp'ed value
						vert = vec4.fromValues(-fsize / 2, 0.0,  0.0, 0.0);
						vertices.push([vert, norm, uv]);

						pushTri(base_index, base_index + 1, base_index + 2);
						pushTri(base_index, base_index + 2, base_index + 3);
						pushTri(base_index, base_index + 3, base_index + 4);
						pushTri(base_index, base_index + 4, base_index + 1);
						pushTri(base_index + 5, base_index + 2, base_index + 1);
						pushTri(base_index + 5, base_index + 3, base_index + 2);
						pushTri(base_index + 5, base_index + 4, base_index + 3);
						pushTri(base_index + 5, base_index + 1, base_index + 4);

						break;
					case FoliageTypes.SAG:
						/*     /\
						      /__\
						     /|  |\
						     \|__|/
						      \  /
						       \/   */
						var level1 = fsize * -0.4,
						    level2 = fsize * -1.2,
						    uv_mid = vec2.create();
						var uv_innerTL = vec2.fromValues(0.25 + 1.25, 0.125),
						    uv_innerTR = vec2.fromValues(0.5 - 0.125, 0.125),
						    uv_innerBR = vec2.fromValues(0.5 - 0.125, 1.0 - 0.125),
						    uv_innerBL = vec2.fromValues(0.25 + 1.25, 1.0 - 0.125);

						norm = vec3.fromValues(0.0, 0.0, 1.0);

						// center
						vert = vec4.fromValues(0.0, 0.0, 0.0, 0.0);
						vec2.lerp(uv, uvTL, uvBR, 0.5);
						vertices.push([vert, norm, uv]);

						// first ring
						vert = vec4.fromValues(-fsize / 2, -fsize / 2, level1, 0.0);
						vec2.lerp(uv_mid, uvTL, uvTR, 0.5);
						vertices.push([vert, norm, uv_mid]);

						vert = vec4.fromValues( fsize / 2, -fsize / 2, level1, 0.0);
						vec2.lerp(uv_mid, uvTR, uvBR, 0.5);
						vertices.push([vert, norm, uv_mid]);

						vert = vec4.fromValues( fsize / 2,  fsize / 2, level1, 0.0);
						vec2.lerp(uv_mid, uvBL, uvBR, 0.5);
						vertices.push([vert, norm, uv_mid]);

						vert = vec4.fromValues(-fsize / 2,  fsize / 2, level1, 0.0);
						vec2.lerp(uv_mid, uvTL, uvBL, 0.5);
						vertices.push([vert, norm, uv_mid]);

						// tips
						vert = vec4.fromValues(0.0, -fsize, level2, 0.0);
						vertices.push([vert, norm, uvTR]);

						vert = vec4.fromValues(fsize,  0.0, level2, 0.0);
						vertices.push([vert, norm, uvBR]);

						vert = vec4.fromValues(0.0,  fsize, level2, 0.0);
						vertices.push([vert, norm, uvBL]);

						vert = vec4.fromValues(-fsize, 0.0, level2, 0.0);
						vertices.push([vert, norm, uvTL]);

						// center, but lower
						vert = vec4.fromValues( 0.0, 0.0, level1 / 16, 0.0);
						vertices.push([vert, norm, uv]);

						// indices
						// cap
						pushTri(base_index, base_index + 2, base_index + 1);
						pushTri(base_index, base_index + 3, base_index + 2);
						pushTri(base_index, base_index + 4, base_index + 3);
						pushTri(base_index, base_index + 1, base_index + 4);
						// outer triangles
						pushTri(base_index + 5, base_index + 1, base_index + 2);
						pushTri(base_index + 6, base_index + 2, base_index + 3);
						pushTri(base_index + 7, base_index + 3, base_index + 4);
						pushTri(base_index + 8, base_index + 4, base_index + 1);

						break;
					case FoliageTypes.BOWL:
						tip_height *= -1.0;

						vert = vec4.fromValues(0.0, 0.0, tip_height, 0.0);
						norm = vec3.fromValues(0.0, 0.0, 1.0);
						vec2.lerp(uv, uvTL, uvBR, 0.5);
						vertices.push([vert, norm, uv]);

						vert = vec4.fromValues(-fsize, -fsize, -tip_height, 0.0);
						norm = vec3.fromValues(-0.5, -0.5, 0.0);
						vertices.push([vert, norm, uvTL]);

						vert = vec4.fromValues(fsize, -fsize, -tip_height, 0.0);
						norm = vec3.fromValues( 0.5, -0.5, 0.0);
						vertices.push([vert, norm, uvTR]);

						vert = vec4.fromValues(fsize, fsize, -tip_height, 0.0);
						norm = vec3.fromValues( 0.5, 0.5, 0.0);
						vertices.push([vert, norm, uvBR]);

						vert = vec4.fromValues(-fsize, fsize, -tip_height, 0.0);
						norm = vec3.fromValues(-0.5, 0.5, 0.0);
						vertices.push([vert, norm, uvBL]);

						vert = vec4.fromValues(0.0, 0.0, tip_height / 2, 0.0);
						norm = vec3.fromValues(0.0, 0.0, 1.0);
						vertices.push([vert, norm, uv]);

						pushTri(base_index, base_index + 1, base_index + 2);
						pushTri(base_index, base_index + 2, base_index + 3);
						pushTri(base_index, base_index + 3, base_index + 4);
						pushTri(base_index, base_index + 4, base_index + 1);

						pushTri(base_index + 5, base_index + 2, base_index + 1);
						pushTri(base_index + 5, base_index + 3, base_index + 2);
						pushTri(base_index + 5, base_index + 4, base_index + 3);
						pushTri(base_index + 5, base_index + 1, base_index + 4);

						//pushQuad(base_index + 1, base_index + 4, base_index + 3, base_index + 2);

						break;
					case FoliageTypes.UMBRELLA:
						vert = vec4.fromValues(0.0, 0.0, tip_height, 0.0);
						norm = vec3.fromValues(0.0, 0.0, 1.0);
						vec2.lerp(uv, uvTL, uvBR, 0.5);
						vertices.push([vert, norm, uv]);

						vert = vec4.fromValues(-fsize, -fsize, -tip_height, 0.0);
						norm = vec3.fromValues(-0.5, -0.5, 0.0);
						vertices.push([vert, norm, uvTL]);

						vert = vec4.fromValues(fsize, -fsize, -tip_height, 0.0);
						norm = vec3.fromValues(0.5, -0.5, 0.0);
						vertices.push([vert, norm, uvTR]);

						vert = vec4.fromValues(fsize, fsize, -tip_height, 0.0);
						norm = vec3.fromValues(0.5, 0.5, 0.0);
						vertices.push([vert, norm, uvBR]);

						vert = vec4.fromValues(-fsize, fsize, -tip_height, 0.0);
						norm = vec3.fromValues(-0.5, 0.5, 0.0);
						vertices.push([vert, norm, uvBL]);

						vert = vec4.fromValues(0.0, 0.0, tip_height / 2, 0.0);
						norm = vec3.fromValues(0.0, 0.0, 1.0);
						// uv still has the previous lerp'ed value
						vertices.push([vert, norm, uv]);

						pushTri(base_index, base_index + 2, base_index + 1);
						pushTri(base_index, base_index + 3, base_index + 2);
						pushTri(base_index, base_index + 4, base_index + 3);
						pushTri(base_index, base_index + 1, base_index + 4);

						break;
				}

				var angle_mat = mat4.create();
				mat4.rotateZ(angle_mat, angle_mat, angle);

				vertices.foreach(function(vertlist) {
					vec4.transformMat4(vertlist[0], vertlist[0], angle_mat);
					vec4.add(vertlist[0], vertlist[0], pos_list[0]);
				}, base_index);
			}

			const SEGMENTS_PER_METER = 0.25;
			const MIN_RADIUS = 0.3;

			function makeBranch(vertices, pushTri, pushQuad, anchor, angle, _branch_lift, foliage_type) {
				if (anchor.length < 2.0) return;
				if (anchor.radius < MIN_RADIUS) return;

				var segment_count = Math.floor(anchor.length * SEGMENTS_PER_METER),
				    base_index = vertices.length,
				    mat = mat4.create(),
				    segment_count = 5,
				    radial_steps = 6,
				    radial_edge = radial_steps + 1,
				    core = vec4.clone(anchor.root),
				    vert,
				    norm,
				    ring_angle,
				    underside_vertices = [];
				if (segment_count < 3) segment_count = 3;
				segment_count += 3;
				mat4.rotateZ(mat, mat, angle);

				for (var segment = 0; segment < segment_count + 1; segment++) {
					var horiz_pos = segment / (segment_count + 1.0), curve;
					// if (_lift_style == OUT) {
					//   curve = horiz_pos * horiz_pos;
					// } else if (_lift_style == IN) {
					//   curve = 1.0 - horiz_pos;
					//   curve *= curve * curve;
					//   curve = 1.0 - curve;
					// } else {
					curve = horiz_pos;
					// }
					var radius = anchor.root[3] * (1.0-horiz_pos);
					if (radius < MIN_RADIUS) radius = MIN_RADIUS;
					core[2] = anchor.root[2] + anchor.lift * curve * _branch_lift;
					// if this is the last segment, don't make a ring of points, make one,
					// in the center, so the branch can end at a point
					if (segment == segment_count) {
						vert = vec4.fromValues(0.0, anchor.length*horiz_pos, 0.0, 0.0);
						vec4.transformMat4(vert, vert, mat);
						vec4.add(vert, vert, core);
						norm = vec4.fromValues(vert[0], 0.0, vert[2]);
						vertices.push([vert, norm, vec2.fromValues(0.249, vert[1])]);
					} else {
						for (var ring=0; ring<=radial_steps; ring++) {
							if (ring == radial_steps || ring == 0) {
								ring_angle = 0;
							} else {
								ring_angle = ring * 2 * Math.PI / radial_steps;
							}
							vert = vec4.fromValues(
								-Math.cos(ring_angle) * radius,
								anchor.length * horiz_pos,
								-Math.sin(ring_angle) * radius,
								0.0
							);
							vec4.transformMat4(vert, vert, mat);
							vec4.add(vert, vert, core);
							norm = vec3.fromValues(vert[0], 0.0, vert[2]);
							var uv = vec2.fromValues((ring / radial_steps) * 0.249, vert[1]);
							vertices.push([vert, norm, uv]);
						}
					}
					underside_vertices.push(vert);
				}

				// now the indices
				for (var segment = 0; segment < segment_count; segment++) {
					for (var ring = 0; ring < radial_steps; ring++) {
						if (segment < segment_count-1) {
							// normal mid-branch segment
							pushQuad(
								base_index + (ring + 0) + (segment + 0) * (radial_edge),
								base_index + (ring + 0) + (segment + 1) * (radial_edge),
								base_index + (ring + 1) + (segment + 1) * (radial_edge),
								base_index + (ring + 1) + (segment + 0) * (radial_edge)
							);
						} else {
							// end-of-branch segment; use triangles
							pushTri(
								base_index + (ring + 1) + segment * (radial_edge),
								base_index + (ring + 0) + segment * (radial_edge),
								vertices.length - 1
							);
						}
					}
				}

				// grab the last point and use it as the origin for the foliage
				var pos_list = vertices[vertices.length - 1];
				makeFoliage(foliage_type, vertices, pushTri, pushQuad, pos_list, anchor.length * 0.56, angle);

				// TODO: vines
			}

			function makeTree(foliage_type) {
				var _default_height = 8 + 4; // + randf*4 + randf*4
				var _default_branches = 2; // 2 + rand % 2
				var _default_lowest_branch = 3.0 / _default_height;
				var _default_base_radius = 0.2 + (_default_height / 20) * 0.5 // randf

				var _current_height = _default_height; // * (0.5f + randf)
				var _current_branches = _default_branches + 2; // + rand % 3
				var _current_lowest_branch = _default_lowest_branch + 0.1; // randf*0.2
				var _current_base_radius = _default_base_radius + 1 // rand%3

				var _branch_reach = 1.25;  // 1 + randf*0.5
				var _branch_lift = 1.5;  // 1 + randf

				var _current_angle_offset = Math.PI;  // randf*2*PI

				var branch_spacing = (0.95 - _current_lowest_branch) / _current_branches;
				var branches = [];

				for (var i=0; i<_current_branches; i++) {
					var vertical_pos = _current_lowest_branch + i*branch_spacing;
					branch = {};
					branch.root = treeTrunkPos(vertical_pos, _current_base_radius, _current_height);
					branch.length = (_current_height - branch.root[2]) * _branch_reach;
					if (_current_height/2 < branch.length) branch.length = _current_height/2;
					branch.lift = branch.length / 2;

					branches.push(branch);
				}

				var vertices = [], indices = [];
				var vert, norm, uv;

				const STEPS = 7.0;

				for (var i=-1; i<branches.length; i++) {
					var core;
					if (i<0) {
						core = treeTrunkPos(0, _current_base_radius, _current_height);
						// widen
						core[3] = core[3] * 1.5;
						// drop a bit
						core[2] = core[2] - 2;
					} else {
						core = branches[i].root;
					}

					for (var ring=0; ring<=STEPS; ring++) {
						var angle;
						if (ring === 0 || ring === STEPS) {
							angle = 0.0;
						} else {
							angle = ring * (2 * Math.PI/STEPS);
						}
						var x = Math.cos(angle), y = Math.sin(angle);
						vert = vec4.create();
						vec4.add(vert, core, vec4.fromValues(x*core[3], y*core[3], 0.0, 0.0));
						norm = vec3.fromValues(x, y, 0.0);
						uv = vec2.fromValues((ring/STEPS)*0.249, core.z);
						vertices.push([vert, norm, uv]);
					}
				}

				// tip vertex
				vert = treeTrunkPos(1.0, _current_base_radius, _current_height);
				vert[3] = 0.0;
				norm = vec3.fromValues(0.0, 0.0, 1.0);
				uv = vec2.fromValues(0.0, 0.0);
				vertices.push([vert, norm, uv]);

				function pushTri(index1, index2, index3) {
					indices.push(index1);
					indices.push(index2);
					indices.push(index3);
				}
				function pushQuad(index1, index2, index3, index4) {
					pushTri(index1, index2, index3);
					pushTri(index1, index3, index4);
				}

				// index lists into the vertices array
				for (var segment=0; segment<branches.length; segment++) {
					for (var ring=0; ring<STEPS; ring++) {
						pushQuad(
							(ring+0) + (segment+0)*(STEPS+1),
							(ring+1) + (segment+0)*(STEPS+1),
							(ring+1) + (segment+1)*(STEPS+1),
							(ring+0) + (segment+1)*(STEPS+1)
						);
					}
				}

				for (var ring=0; ring<STEPS; ring++) {
					pushTri(
						(ring+1) + (branches.length)*(STEPS+1),
						vertices.length - 1,
						(ring+0) + (branches.length)*(STEPS+1)
					);
				}

				// type==_canopy would not divide _current_height by 2
				makeFoliage(foliage_type, vertices, pushTri, pushQuad, vertices[vertices.length-1], _current_height/2, 0.0);

				// type==_evergreen would just call makeFoliage a couple more times
				for (var i=0; i<branches.length; i++) {
					var angle = _current_angle_offset + i * ((2*Math.PI / branches.length) + Math.PI);
					makeBranch(vertices, pushTri, pushQuad, branches[i], angle, _branch_lift, foliage_type);
				}

				return [vertices, indices];
			}

			// Returns the list of buffers
			function initBuffers(gl) {
				var [vertices, indices] = makeTree(FoliageTypes.UMBRELLA);
				const ROWS = 4;
				const COLS = 4;
				const VERTICES = vertices.length;

				// rearrange data in vertices
				var vertex_f32 = new Float32Array(VERTICES * 3),
					norm_f32 = new Float32Array(VERTICES * 3),
					uv_f32 = new Float32Array(VERTICES * 2);
				for (var i=0; i<vertices.length; i++) {
					vertex_f32.set(vertices[i][0].subarray(0, 3), i*3);
					norm_f32.set(vertices[i][1], i*3);
					uv_f32.set(vertices[i][2], i*2);
				}

				var vertbuf = gl.createBuffer();
				gl.bindBuffer(gl.ARRAY_BUFFER, vertbuf);
				gl.bufferData(gl.ARRAY_BUFFER, vertex_f32, gl.STATIC_DRAW);

				var normbuf = gl.createBuffer();
				gl.bindBuffer(gl.ARRAY_BUFFER, normbuf);
				gl.bufferData(gl.ARRAY_BUFFER, norm_f32, gl.STATIC_DRAW);

				var uvbuf = gl.createBuffer();
				gl.bindBuffer(gl.ARRAY_BUFFER, uvbuf);
				gl.bufferData(gl.ARRAY_BUFFER, uv_f32, gl.STATIC_DRAW);

				var indexbuf = gl.createBuffer();
				gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexbuf);
				gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(indices), gl.STATIC_DRAW);
				// yes, this is extra
				indexbuf.length = indices.length;

				var model = mat4.create();
				mat4.rotateX(model, model, -Math.PI / 2);
				var modelarr = [];
				// copy the nth column of model for each vertex, into each of n new Float32Arrays
				// model is really a Float32Array, in column-major order; exploit that
				for (var i = 0; i < COLS; i++) {
					f32 = new Float32Array(ROWS * VERTICES);
					col = model.subarray(i * ROWS, (i+1) * ROWS);
					for (var j = 0; j < VERTICES; j++) {
						f32.set(col, j * ROWS);
					}
					modelarr.push(f32);
				}

				var modelbuf0 = gl.createBuffer();
				gl.bindBuffer(gl.ARRAY_BUFFER, modelbuf0);
				gl.bufferData(gl.ARRAY_BUFFER, modelarr[0], gl.STATIC_DRAW);

				var modelbuf1 = gl.createBuffer();
				gl.bindBuffer(gl.ARRAY_BUFFER, modelbuf1);
				gl.bufferData(gl.ARRAY_BUFFER, modelarr[1], gl.STATIC_DRAW);

				var modelbuf2 = gl.createBuffer();
				gl.bindBuffer(gl.ARRAY_BUFFER, modelbuf2);
				gl.bufferData(gl.ARRAY_BUFFER, modelarr[2], gl.STATIC_DRAW);

				var modelbuf3 = gl.createBuffer();
				gl.bindBuffer(gl.ARRAY_BUFFER, modelbuf3);
				gl.bufferData(gl.ARRAY_BUFFER, modelarr[3], gl.STATIC_DRAW);

				return [vertbuf, normbuf, uvbuf, indexbuf, modelbuf0, modelbuf1, modelbuf2,
				        modelbuf3];
			}

			function texLoaded(gl, img, tex) {
				gl.bindTexture(gl.TEXTURE_2D, tex);
				gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, img);
				gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
				gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR_MIPMAP_NEAREST);
				gl.generateMipmap(gl.TEXTURE_2D);
				gl.bindTexture(gl.TEXTURE_2D, null);
			}

			function initTextures(gl) {
				tree = gl.createTexture();
				treeImage = new Image();
				treeImage.onload = function() { texLoaded(gl, treeImage, tree); }
				treeImage.src = 'textures/bark1.bmp';

				return [tree];
			}

			function start() {
				var canvas = document.getElementById("glcanvas");
				gl = null;
				try {
					gl = canvas.getContext("webgl") || canvas.getContext("experimental-webgl");
				}
				catch(e) {alert(e);}

				if (!gl) {
					alert("Can't get \"webgl\" context from canvas; maybe no WebGL support?");
					return;
				}

				gl.clearColor(0.0, 0.0, 0.0, 1.0);
				gl.enable(gl.DEPTH_TEST);
				gl.depthFunc(gl.LEQUAL);
				gl.clear(gl.COLOR_BUFFER_BIT|gl.DEPTH_BUFFER_BIT);

				attributes = initShaders(gl);
				buffers = initBuffers(gl);
				textures = initTextures(gl);

				// identity * translation
				vm = mat4.create();
				mat4.translate(vm, vm, vec3.fromValues(0, -10, -50));
				pm = mat4.perspective(mat4.create(), Math.PI/4, 800.0/600.0, 0.1, 100);

				// Do I really need this extra scope?  Eh, why not.
				(function() {
					var requestAnimationFrame = (window.requestAnimationFrame ||
					                             window.mozRequestAnimationFrame ||
					                             window.webkitRequestAnimationFrame ||
					                             window.msRequestAnimationFrame);
					window.requestAnimationFrame = requestAnimationFrame;
				})();
				window.requestAnimationFrame(drawScene);
			}

			var firsttimestamp = null;
			var fpstimestamp = null;
			var frames = 0;

			function drawScene(timestamp) {
				const SECONDS = 3;  // for a full revolution
				const RADS_PER_SEC = 2*Math.PI / SECONDS;
				if (firsttimestamp === null) {
					firsttimestamp = timestamp;
				}
				if ((timestamp - firsttimestamp) > SECONDS*1000) {
					firsttimestamp += SECONDS*1000;
				}
				if (fpstimestamp !== null) {
					if (timestamp - fpstimestamp > 1000) {
						document.getElementById('fps').firstChild.textContent = frames.toFixed(0);
						fpstimestamp = timestamp;
						frames = 0;
					}
				} else {
					fpstimestamp = timestamp;
				}
				gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

				// wouldn't it be nice if javascript did python-style unpacking...
				// oh look, it does, but not in IE.  well, too bad, IE.
				var [[posattr, uvattr, modelattr0, modelattr1, modelattr2, modelattr3],
				     [proj, view, tex]] = attributes,
					[vertbuf, normbuf, uvbuf, indexbuf, modelbuf0, modelbuf1, modelbuf2,
					 modelbuf3] = buffers,
					[tree] = textures;

				// rotate around the scene once every few seconds
				radians = ((timestamp - firsttimestamp) / 1000) * RADS_PER_SEC;
				viewmatrix = mat4.create();
				mat4.rotateY(viewmatrix, vm, radians);
				gl.uniformMatrix4fv(view, false, viewmatrix);
				gl.uniformMatrix4fv(proj, false, pm);

				gl.activeTexture(gl.TEXTURE0);
				gl.bindTexture(gl.TEXTURE_2D, tree);
				gl.uniform1i(tex, 0);

				gl.bindBuffer(gl.ARRAY_BUFFER, vertbuf);
				gl.vertexAttribPointer(posattr, 3, gl.FLOAT, false, 0, 0);

				gl.bindBuffer(gl.ARRAY_BUFFER, uvbuf);
				gl.vertexAttribPointer(uvattr, 2, gl.FLOAT, false, 0, 0);

				gl.bindBuffer(gl.ARRAY_BUFFER, modelbuf0);
				gl.vertexAttribPointer(modelattr0, 4, gl.FLOAT, false, 0, 0)
				gl.bindBuffer(gl.ARRAY_BUFFER, modelbuf1);
				gl.vertexAttribPointer(modelattr1, 4, gl.FLOAT, false, 0, 0)
				gl.bindBuffer(gl.ARRAY_BUFFER, modelbuf2);
				gl.vertexAttribPointer(modelattr2, 4, gl.FLOAT, false, 0, 0)
				gl.bindBuffer(gl.ARRAY_BUFFER, modelbuf3);
				gl.vertexAttribPointer(modelattr3, 4, gl.FLOAT, false, 0, 0)

				gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexbuf);
				gl.drawElements(gl.TRIANGLES, indexbuf.length, gl.UNSIGNED_SHORT, 0);

				window.requestAnimationFrame(drawScene);

				frames++;
			}
		</script>
	</head>
	<body onload="start()">
		<canvas id="glcanvas" width="800" height="600">
		Your browser doesn't appear to support the HTML5 <code>&lt;canvas&gt;</code> element.
		</canvas>
		<p><span id="fps">???</span> FPS</p>
		<script type="x-shader/x-fragment" id="frag-shader">
			#version 100

			varying lowp vec2 vUV;

			uniform sampler2D texture;

			void main(void) {
				gl_FragColor = texture2D(texture, vUV);
			}
		</script>
		<script type="x-shader/x-vertex" id="vert-shader">
			#version 100

			attribute vec3 pos;
			attribute vec2 uv;
			attribute vec4 model0;
			attribute vec4 model1;
			attribute vec4 model2;
			attribute vec4 model3;

			uniform mat4 view;
			uniform mat4 proj;

			varying lowp vec2 vUV;

			void main(void) {
				mat4 model;
				model[0] = model0;
				model[1] = model1;
				model[2] = model2;
				model[3] = model3;
				gl_Position = proj * view * model * vec4(pos, 1.0);
				vUV = uv;
			}
		</script>
	</body>
</html>
