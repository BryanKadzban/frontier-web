<!DOCTYPE html>
<html>
	<head>
		<script src="gl-matrix-min.js"></script>
		<script src="tree.js"></script>
		<script>
			var gl;
			var buffers = {};
			var attributes = {};
			var textures;  // [tree]
			var vm, pm;

			Array.prototype.foreach = function(fn, start, limit) {
				if (start === undefined) start = 0;
				if (limit === undefined) limit = this.length;

				for (var i=start; i<limit; i++) {
					fn(this[i], i);
				}
			}

			function Vertex(vert, norm, uv, model) {
				this.vertex = vert;
				this.normal = norm;
				this.uv = uv;
				this.model = model;
			}

			function getShader(gl, id) {
				var shaderScript = document.getElementById(id);
				var shader = null;

				if (!shaderScript) return null;

				if (shaderScript.type == 'x-shader/x-fragment') {
					shader = gl.createShader(gl.FRAGMENT_SHADER);
				} else if (shaderScript.type == 'x-shader/x-vertex') {
					shader = gl.createShader(gl.VERTEX_SHADER);
				} else {
					return null;
				}

				var currentChild = shaderScript.firstChild;
				var source = "";

				while (currentChild) {
					if (currentChild.nodeType == currentChild.TEXT_NODE) {
						source += currentChild.textContent;
					}
					currentChild = currentChild.nextSibling;
				}

				gl.shaderSource(shader, source);
				gl.compileShader(shader);

				if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
					alert('Error compiling ' + id + ' shader: ' + gl.getShaderInfoLog(shader));
					return null;
				}

				return shader;
			}

			// Returns a list of lists; first list is the attribute locations,
			// second list is the uniform locations
			function initShaders(gl) {
				var frag = getShader(gl, "frag-shader");
				var vert = getShader(gl, "vert-shader");

				var prog = gl.createProgram();
				gl.attachShader(prog, vert);
				gl.attachShader(prog, frag);
				gl.linkProgram(prog);

				if (!gl.getProgramParameter(prog, gl.LINK_STATUS)) {
					alert('Link failed: ' + gl.getProgramInfoLog(prog));
				}

				gl.useProgram(prog);

				var attrs = {
					attrs: {
						pos: gl.getAttribLocation(prog, 'pos'),
						uv: gl.getAttribLocation(prog, 'uv'),
						model0: gl.getAttribLocation(prog, 'model0'),
						model1: gl.getAttribLocation(prog, 'model1'),
						model2: gl.getAttribLocation(prog, 'model2'),
						model3: gl.getAttribLocation(prog, 'model3'),
					},
					uniforms: {
						proj: gl.getUniformLocation(prog, 'proj'),
						view: gl.getUniformLocation(prog, 'view'),
						tex: gl.getUniformLocation(prog, 'texture'),
					},
				};

				gl.enableVertexAttribArray(attrs.attrs.pos);
				gl.enableVertexAttribArray(attrs.attrs.uv);
				gl.enableVertexAttribArray(attrs.attrs.model0);
				gl.enableVertexAttribArray(attrs.attrs.model1);
				gl.enableVertexAttribArray(attrs.attrs.model2);
				gl.enableVertexAttribArray(attrs.attrs.model3);

				return attrs;
			}

			// Returns the list of buffers
			function initBuffers(gl) {
				var vertices = [], indices = [];
				var pos = vec3.fromValues(-20.0, -20.0, 0.0);
				var pos2 = vec3.fromValues(20.0, 20.0, 0.0);
				var pos3 = vec3.fromValues(0.0, 0.0, 0.0);
				var tree = new Tree(TreeType.EVERGREEN, FoliageType.UMBRELLA, false, BranchType.NORMAL, pos);
				var tree2 = new Tree(TreeType.NORMAL, FoliageType.UMBRELLA, false, BranchType.NORMAL, pos2);
				var tree3 = new Tree(TreeType.CANOPY, FoliageType.UMBRELLA, false, BranchType.NORMAL, pos3);
				tree.Build(vertices, indices);
				tree2.Build(vertices, indices);
				tree3.Build(vertices, indices);
				const ROWS = 4;
				const COLS = 4;
				const VERTICES = vertices.length;

				// rearrange data in vertices
				var vertex_f32 = new Float32Array(VERTICES * 3),
					norm_f32 = new Float32Array(VERTICES * 3),
					uv_f32 = new Float32Array(VERTICES * 2),
					models_f32 = [new Float32Array(VERTICES * ROWS),
					              new Float32Array(VERTICES * ROWS),
					              new Float32Array(VERTICES * ROWS),
					              new Float32Array(VERTICES * ROWS)];
				for (var i=0; i<vertices.length; i++) {
					vertex_f32.set(vertices[i].vertex.subarray(0, 3), i*3);
					norm_f32.set(vertices[i].normal, i*3);
					uv_f32.set(vertices[i].uv, i*2);
					// copy the nth column of vertices[i].model for each vertex,
					// into each of n new Float32Arrays.  .model is really a
					// Float32Array, in column-major order; exploit that.
					for (var col = 0; col < COLS; col++) {
						var col_f32 = vertices[i].model.subarray(col*ROWS, (col+1)*ROWS);
						models_f32[col].set(col_f32, i * ROWS);
					}
				}

				var bufs = {
					vert: gl.createBuffer(),
					norm: gl.createBuffer(),
					uv: gl.createBuffer(),
					index: gl.createBuffer(),
					model0: gl.createBuffer(),
					model1: gl.createBuffer(),
					model2: gl.createBuffer(),
					model3: gl.createBuffer(),
				};

				gl.bindBuffer(gl.ARRAY_BUFFER, bufs.vert);
				gl.bufferData(gl.ARRAY_BUFFER, vertex_f32, gl.STATIC_DRAW);

				gl.bindBuffer(gl.ARRAY_BUFFER, bufs.norm);
				gl.bufferData(gl.ARRAY_BUFFER, norm_f32, gl.STATIC_DRAW);

				gl.bindBuffer(gl.ARRAY_BUFFER, bufs.uv);
				gl.bufferData(gl.ARRAY_BUFFER, uv_f32, gl.STATIC_DRAW);

				gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, bufs.index);
				gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(indices), gl.STATIC_DRAW);
				// yes, this is extra
				bufs.index.length = indices.length;

				gl.bindBuffer(gl.ARRAY_BUFFER, bufs.model0);
				gl.bufferData(gl.ARRAY_BUFFER, models_f32[0], gl.STATIC_DRAW);

				gl.bindBuffer(gl.ARRAY_BUFFER, bufs.model1);
				gl.bufferData(gl.ARRAY_BUFFER, models_f32[1], gl.STATIC_DRAW);

				gl.bindBuffer(gl.ARRAY_BUFFER, bufs.model2);
				gl.bufferData(gl.ARRAY_BUFFER, models_f32[2], gl.STATIC_DRAW);

				gl.bindBuffer(gl.ARRAY_BUFFER, bufs.model3);
				gl.bufferData(gl.ARRAY_BUFFER, models_f32[3], gl.STATIC_DRAW);

				return bufs;
			}

			function texLoaded(gl, img, tex) {
				gl.bindTexture(gl.TEXTURE_2D, tex);
				gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, img);
				gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
				gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR_MIPMAP_NEAREST);
				gl.generateMipmap(gl.TEXTURE_2D);
				gl.bindTexture(gl.TEXTURE_2D, null);
				// Add a couple useful accessors:
				tex.width = img.width;
				tex.height = img.height;
			}

			function initTextures(gl) {
				var texs = {
					bark: gl.createTexture(),
					foliage: gl.createTexture(),
					vine: gl.createTexture(),
				}, images = {
					bark: new Image(),
					foliage: new Image(),
					vine: new Image(),
				}, tex_values = new Array(), tex_count;

				for (key in texs) {
					tex_values.push(texs[key]);
				}

				tex_count = tex_values.length;

				var cb = function() { if (--tex_count == 0) Tree.Setup(gl, tex_values); };

				images.bark.onload = function() { texLoaded(gl, images.bark, texs.bark); cb(); };
				images.bark.src = 'textures/bark1.bmp';
				images.foliage.onload = function() { texLoaded(gl, images.foliage, texs.foliage); cb(); };
				images.foliage.src = 'textures/foliage.png';
				images.vine.onload = function() { texLoaded(gl, images.vine, texs.vine); cb(); };
				images.vine.src = 'textures/vines.png';

				return texs;
			}

			function start() {
				var canvas = document.getElementById("glcanvas");
				gl = null;
				try {
					gl = canvas.getContext("webgl") || canvas.getContext("experimental-webgl");
				}
				catch(e) {alert(e);}

				if (!gl) {
					alert("Can't get \"webgl\" context from canvas; maybe no WebGL support?");
					return;
				}

				gl.clearColor(0.0, 0.0, 0.0, 1.0);
				gl.enable(gl.DEPTH_TEST);
				gl.depthFunc(gl.LEQUAL);
				gl.clear(gl.COLOR_BUFFER_BIT|gl.DEPTH_BUFFER_BIT);

				attributes = initShaders(gl);
				buffers = initBuffers(gl);
				textures = initTextures(gl);

				// identity * translation
				vm = mat4.create();
				mat4.translate(vm, vm, vec3.fromValues(0, -8, -70));
				pm = mat4.perspective(mat4.create(), Math.PI/4, 800.0/600.0, 0.1, 150);

				gl.enable(gl.BLEND);
				gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);

				// Do I really need this extra scope?  Eh, why not.
				(function() {
					var requestAnimationFrame = (window.requestAnimationFrame ||
					                             window.mozRequestAnimationFrame ||
					                             window.webkitRequestAnimationFrame ||
					                             window.msRequestAnimationFrame);
					window.requestAnimationFrame = requestAnimationFrame;
				})();
				window.requestAnimationFrame(drawScene);
			}

			var firsttimestamp = null;
			var fpstimestamp = null;
			var frames = 0;

			function drawScene(timestamp) {
				const SECONDS = 3;  // for a full revolution
				const RADS_PER_SEC = 2*Math.PI / SECONDS;
				if (firsttimestamp === null) {
					firsttimestamp = timestamp;
				}
				if ((timestamp - firsttimestamp) > SECONDS*1000) {
					firsttimestamp += SECONDS*1000;
				}
				if (fpstimestamp !== null) {
					if (timestamp - fpstimestamp > 1000) {
						document.getElementById('fps').firstChild.textContent = frames.toFixed(0);
						fpstimestamp = timestamp;
						frames = 0;
					}
				} else {
					fpstimestamp = timestamp;
				}
				gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

				// rotate around the scene once every few seconds
				radians = ((timestamp - firsttimestamp) / 1000) * RADS_PER_SEC;
				viewmatrix = mat4.create();
				mat4.rotateY(viewmatrix, vm, radians);
				gl.uniformMatrix4fv(attributes.uniforms.view, false, viewmatrix);
				gl.uniformMatrix4fv(attributes.uniforms.proj, false, pm);

				gl.activeTexture(gl.TEXTURE0);
				gl.bindTexture(gl.TEXTURE_2D, Tree.texture);
				gl.uniform1i(attributes.uniforms.tex, 0);

				gl.bindBuffer(gl.ARRAY_BUFFER, buffers.vert);
				gl.vertexAttribPointer(attributes.attrs.pos, 3, gl.FLOAT, false, 0, 0);

				gl.bindBuffer(gl.ARRAY_BUFFER, buffers.uv);
				gl.vertexAttribPointer(attributes.attrs.uv, 2, gl.FLOAT, false, 0, 0);

				gl.bindBuffer(gl.ARRAY_BUFFER, buffers.model0);
				gl.vertexAttribPointer(attributes.attrs.model0, 4, gl.FLOAT, false, 0, 0)
				gl.bindBuffer(gl.ARRAY_BUFFER, buffers.model1);
				gl.vertexAttribPointer(attributes.attrs.model1, 4, gl.FLOAT, false, 0, 0)
				gl.bindBuffer(gl.ARRAY_BUFFER, buffers.model2);
				gl.vertexAttribPointer(attributes.attrs.model2, 4, gl.FLOAT, false, 0, 0)
				gl.bindBuffer(gl.ARRAY_BUFFER, buffers.model3);
				gl.vertexAttribPointer(attributes.attrs.model3, 4, gl.FLOAT, false, 0, 0)

				gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, buffers.index);
				gl.drawElements(gl.TRIANGLES, buffers.index.length, gl.UNSIGNED_SHORT, 0);

				window.requestAnimationFrame(drawScene);

				frames++;
			}
		</script>
	</head>
	<body onload="start()">
		<canvas id="glcanvas" width="800" height="600">
		Your browser doesn't appear to support the HTML5 <code>&lt;canvas&gt;</code> element.
		</canvas>
		<p><span id="fps">???</span> FPS, <span id="debug"></span></p>
		<canvas id="texture" width="256" height="256">
		</canvas>
		<script type="x-shader/x-vertex" id="vert-shader">
			#version 100

			attribute vec3 pos;
			attribute vec2 uv;
			attribute vec4 model0;
			attribute vec4 model1;
			attribute vec4 model2;
			attribute vec4 model3;

			uniform mat4 view;
			uniform mat4 proj;

			varying lowp vec2 vUV;

			void main(void) {
				mat4 model;
				model[0] = model0;
				model[1] = model1;
				model[2] = model2;
				model[3] = model3;
				gl_Position = proj * view * model * vec4(pos, 1.0);
				vUV = uv;
			}
		</script>
		<script type="x-shader/x-fragment" id="frag-shader">
			#version 100

			varying lowp vec2 vUV;

			uniform sampler2D texture;

			void main(void) {
				gl_FragColor = texture2D(texture, vUV);
			}
		</script>
		<script type="x-shader/x-vertex" id="texture-vshader">
			#version 100

			uniform mat4 proj;
			attribute vec3 pos;
			attribute vec4 color;
			attribute vec2 uv;
			varying lowp vec2 vUV;
			varying lowp vec4 vColor;
			void main(void) {
				vec4 localpos;
				localpos.xy = pos.xy;
				localpos.z = pos.z - 10.0;
				localpos.w = 1.0;
				gl_Position = proj * localpos;
				vUV = uv;
				vColor = color;
			}
		</script>
		<script type="x-shader/x-fragment" id="texture-fshader">
			#version 100

			varying lowp vec2 vUV;
			varying lowp vec4 vColor;
			uniform sampler2D tex;

			void main(void) {
				lowp vec4 texel = texture2D(tex, vUV);
				// emulate the old fixed-function pipeline's blending
				gl_FragColor = vColor * texel;
			}
		</script>
	</body>
</html>
